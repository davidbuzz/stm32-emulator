diff --git a/os/hal/ports/STM32/STM32F4xx/hal_lld.c b/os/hal/ports/STM32/STM32F4xx/hal_lld.c
index 63b30c2..6e6a7fc 100644
--- a/os/hal/ports/STM32/STM32F4xx/hal_lld.c
+++ b/os/hal/ports/STM32/STM32F4xx/hal_lld.c
@@ -71,8 +71,8 @@ static void hal_lld_backup_domain_init(void) {
   /* No LSE Bypass.*/
   RCC->BDCR |= RCC_BDCR_LSEON;
 #endif
-  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
-    ;                                       /* Waits until LSE is stable.   */
+  // while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
+  //   ;                                       /* Waits until LSE is stable.   */
 #endif
 
 #if HAL_USE_RTC
@@ -91,8 +91,8 @@ static void hal_lld_backup_domain_init(void) {
   rccEnableBKPSRAM(true);
 
   PWR->CSR |= PWR_CSR_BRE;
-  while ((PWR->CSR & PWR_CSR_BRR) == 0)
-    ;                                /* Waits until the regulator is stable */
+  // while ((PWR->CSR & PWR_CSR_BRR) == 0)
+  //   ;                                /* Waits until the regulator is stable */
 #else
   PWR->CSR &= ~PWR_CSR_BRE;
 #endif /* STM32_BKPRAM_ENABLE */
@@ -170,16 +170,16 @@ void stm32_clock_init(void) {
 
   /* HSI setup, it enforces the reset situation in order to handle possible
      problems with JTAG probes and re-initializations.*/
-  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
-  while (!(RCC->CR & RCC_CR_HSIRDY))
-    ;                                       /* Wait until HSI is stable.    */
+  // RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
+  // while (!(RCC->CR & RCC_CR_HSIRDY))
+  //   ;                                       /* Wait until HSI is stable.    */
 
   /* HSI is selected as new source without touching the other fields in
      CFGR. Clearing the register has to be postponed after HSI is the
      new source.*/
-  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
-  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
-    ;                                       /* Wait until HSI is selected.  */
+  // RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
+  // while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
+  //   ;                                       /* Wait until HSI is selected.  */
 
   /* Registers finally cleared to reset values.*/
   RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
@@ -194,15 +194,15 @@ void stm32_clock_init(void) {
   /* No HSE Bypass.*/
   RCC->CR |= RCC_CR_HSEON;
 #endif
-  while ((RCC->CR & RCC_CR_HSERDY) == 0)
-    ;                           /* Waits until HSE is stable.               */
+  // while ((RCC->CR & RCC_CR_HSERDY) == 0)
+  //   ;                           /* Waits until HSE is stable.               */
 #endif
 
 #if STM32_LSI_ENABLED
   /* LSI activation.*/
   RCC->CSR |= RCC_CSR_LSION;
-  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
-    ;                           /* Waits until LSI is stable.               */
+  // while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
+  //   ;                           /* Waits until LSI is stable.               */
 #endif
 
 #if STM32_ACTIVATE_PLL
@@ -213,8 +213,8 @@ void stm32_clock_init(void) {
 
   /* Synchronization with voltage regulator stabilization.*/
 #if defined(STM32F4XX)
-  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
-    ;                           /* Waits until power regulator is stable.   */
+  // while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
+  //   ;                           /* Waits until power regulator is stable.   */
 
 #if STM32_OVERDRIVE_REQUIRED
   /* Overdrive activation performed after activating the PLL in order to save
@@ -223,14 +223,14 @@ void stm32_clock_init(void) {
   while (!(PWR->CSR & PWR_CSR_ODRDY))
       ;
   PWR->CR |= PWR_CR_ODSWEN;
-  while (!(PWR->CSR & PWR_CSR_ODSWRDY))
-      ;
+  // while (!(PWR->CSR & PWR_CSR_ODSWRDY))
+  //     ;
 #endif /* STM32_OVERDRIVE_REQUIRED */
 #endif /* defined(STM32F4XX) */
 
   /* Waiting for PLL lock.*/
-  while (!(RCC->CR & RCC_CR_PLLRDY))
-    ;
+  // while (!(RCC->CR & RCC_CR_PLLRDY))
+  //   ;
 #endif /* STM32_ACTIVATE_PLL */
 
 #if STM32_ACTIVATE_PLLI2S
@@ -240,8 +240,8 @@ void stm32_clock_init(void) {
   RCC->CR |= RCC_CR_PLLI2SON;
 
   /* Waiting for PLL lock.*/
-  while (!(RCC->CR & RCC_CR_PLLI2SRDY))
-    ;
+  // while (!(RCC->CR & RCC_CR_PLLI2SRDY))
+  //   ;
 #endif /* STM32_ACTIVATE_PLLI2S */
 
 #if STM32_ACTIVATE_PLLSAI
@@ -251,8 +251,8 @@ void stm32_clock_init(void) {
   RCC->CR |= RCC_CR_PLLSAION;
 
   /* Waiting for PLL lock.*/
-  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
-    ;
+  // while (!(RCC->CR & RCC_CR_PLLSAIRDY))
+  //   ;
 #endif /* STM32_ACTIVATE_PLLSAI */
 
   /* Other clock-related settings (dividers, MCO etc).*/
@@ -314,15 +314,15 @@ void stm32_clock_init(void) {
   FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                FLASH_ACR_DCEN | STM32_FLASHBITS;
 #endif
-  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
-         (STM32_FLASHBITS & FLASH_ACR_LATENCY_Msk)) {
-  }
+  // while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
+  //        (STM32_FLASHBITS & FLASH_ACR_LATENCY_Msk)) {
+  // }
 
   /* Switching to the configured clock source if it is different from HSI.*/
 #if (STM32_SW != STM32_SW_HSI)
   RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
-  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
-    ;
+  // while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
+  //   ;
 #endif
 #endif /* STM32_NO_INIT */
 
